%-*-coding: utf-8-*-
\FloatBarrier
\chapter{Дополнения к алгоритму}

\FloatBarrier
\section{Альтернативный способ кодирования структуры сети}

Предложенный способ кодирования структуры сети можно улучшить, если воспользоваться наблюдением, что можно последовательно добавлять в одно из исходных деревьев ретикулярную и обычную вершину, получая каждый раз корректную сеть.
Таким образом, проведя такую операцию $k$ раз, получится сеть с гибридизационным числом $k$.
После этого необходимо добавить утверждения из параграфов~\ref{sec:mapping}~и~\ref{sec:parent-child}, связав с оставшиеся деревья с сетью.
Потенциальные плюсы такого подхода в том, что сеть задается меньшим количеством переменных и утверждений, что, в теории, позволит ускорить работу солвера.

Для начала условимся, что добавление ретикулярного события в дерево описывается следующим образом:

\begin{enumerate}
	\item Выбираются два ребра, которые будут подразбиты для вставки в них новых вершин.
	\item В одно из ребер вставляется обычная вершина, в другое вставляется ретикулярная вершина.
	\item Вторым предком новой ретикулярной вершины становится соответственно новая обычная вершина.
\end{enumerate}

Чтобы нумеровать ребра воспользуемся следующей схемой: рассмотрим обычную вершину $v$; ребро соединяющее вершину $v$ с её предком будет иметь тот же номер, что и вершина $v$.
В случае ретикулярной вершины $u$, для описания ребер ведущих в предков понадобится два номера, поэтому номера ребер ведущих к предкам ретикулярной вершины $u$ будут иметь номера $2n - 1 + k + i$ и $2n + k + i$, если $u$ является $i$--й по порядку ретикулярной вершиной.

Для того, чтобы закодировать эти события, понадобятся следующие переменные:

\begin{itemize}
	\item $h_{v,e}$, где $v \in R, e \in E$. \\
	$h_{v,e}$ истинно тогда и только тогда, когда ретикулярная вершина $v$ вставлена в ребро $e$.
	\item $r_{v,e}$, где $v \in V, e \in E$. \\
	$r_{v,e}$ истинно тогда и только тогда, когда обычная вершина $v$ вставлена в ребро $e$.
\end{itemize}

Наиболее простой способ кодирования заключается в том, чтобы ввести следствие из новых утверждений, в утверждения, представленные в параграфе~\ref{sec:structure}.
Такой подход не уменьшит общее количество утверждений, но позволит уменьшить количество реально значимых, независимых утверждений, что вместе с выбором подходящего солвера, позволит значительно ускорить перебор.

Для того, чтобы это осуществить, необходимо лишь указать, какие из переменных, отвечающих за предков будут истинны, после введения всех ретикулярных событий.

Для начала заметим, что нет никакого смысла добавлять одновременно и ретикулярную и обычную вершину в одно и то же ребро.
Кроме того, понадобятся уже известные ALO и AMO утверждения для того, чтобы обеспечить уникальность переменных $h$ и $r$.
%Эти утверждения приведены в секции 1 Таблицы~\ref{second-enc-table}.

% \begin{table}[t]
% \centering
% \caption{Утверждения для кодирования структуры сети.}
% \begin{tabular}{l | l | l}
%  & Утверждение & Диапазон \\

%  \hline
%  1.1 &
%  $\neg h_{u_i, e} \vee \neg r_{v_i, e}$ &
%  $v_i \in V; u_i \in R; e \in E$
%  \\
%  \hdashline
%  1.2 &
%  $\mathrm{ALO}_h(v)$ &
%  \multirow{2}{*}{$v \in R; E(v)$}
%  \\
%  1.3 &
%  $\mathrm{AMO}_h(v)$ &
% %  $v \in R; E(v)$
%  \\
%  \hdashline
%  1.4 &
%  $\mathrm{ALO}_r(v)$ &
%  \multirow{2}{*}{$v \in V; E(v)$}
%  \\
%  1.5 &
%  $\mathrm{AMO}_r(v)$ &
% %  $v \in V; E(v)$
%  \\

%  \hline
%  2.1 &
%  $(\neg h_{u_0, e} \wedge \neg r_{v_0, e} \dots \neg h_{u_k, e} \wedge \neg r_{v_k, e}) \rightarrow p_{v_e, u_e}$ &
%  $u \in R; v \in V; e \in E; v_e \in e; u_e = p(v_e)$
%  \\
%  \hdashline
%  2.2 &
%  $(h_{u_i, e} \wedge \neg h_{u_{i+1}, e} \wedge \neg r_{v_{i+1}, e} \dots \neg h_{u_k, e} \wedge \neg r_{v_k, e}) \rightarrow p_{v_e, u_i}$ &
%  \multirow{2}{*}{$u \in R; v \in V; e \in E; v_e \in e$}
%  \\
%  2.3 &
%  $(r_{v_i, e} \wedge \neg h_{u_{i+1}, e} \wedge \neg r_{v_{i+1}, e} \dots \neg h_{u_k, e} \wedge \neg r_{v_k, e}) \rightarrow p_{v_e, v_i}$ &
% % $u \in R; v \in V; e \in E; v_e \in e$
%  \\

%  \hline
%  3.1 &
%  $(h_{u_i, e} \wedge \neg h_{u_{i+1}, e} \wedge \neg r_{v_{i+1}, e} \dots \neg h_{u_k, e} \wedge \neg r_{v_k, e}) \rightarrow (lp_{u_i, u_e} \vee lp_{u_i, v_i})$ &
%  \multirow{2}{*}{$u \in R; v \in V; e \in E; u_e \in e$}
%  \\
%  3.2 &
%  $(h_{u_i, e} \wedge \neg h_{u_{i+1}, e} \wedge \neg r_{v_{i+1}, e} \dots \neg h_{u_k, e} \wedge \neg r_{v_k, e}) \rightarrow (rp_{u_i, u_e} \vee rp_{u_i, v_i})$ &
%  % $u \in R; v \in V; e \in E; u_e \in e$
%  \\
%  \hdashline
%  3.3
%  $(h_{u_i, e} \wedge \neg h_{u_{i+1}, e} \wedge \neg r_{v_{i+1}, e} \dots \neg h_{u_k, e} \wedge \neg r_{v_k, e}) \rightarrow (rp_{u_i, u_e} \vee rp_{u_i, v_i})$ &

% \end{tabular}
% \label{second-enc-table}
% \end{table}

Теперь рассмотрим обычную вершину $v$.
Если в ребро над этой вершиной не добавлялось никаких новых вершин, то её предок не изменился и является её предком в дереве.
Иначе, её предком будет вершина, добавленная самой последней в ребро над ней.
Так как вершины добавляются в сеть в порядке возрастания, то достаточно утверждения, что на $i$--м шаге вершина была добавлена в ребро $e$, а на шагах $i+1, i+2, \dots , k$ в ребро $e$ ничего не было добавлено.
%Эти утверждения приведены в секции 2 Таблицы~\ref{second-enc-table}.

Аналогично для ретикулярных вершин.
Если в ребра, ведущие в предков ретикулярной вершины $v$ ничего не было добавлено, то эти ребра ведут либо в обычную вершину добавленную на том же шаге, либо в сответствующего предка из дерева.
Иначе, соответствующим предком будет вершина, добавленная самой последней в соответствующее ребро.
%Эти утверждения приведены в секции 3 Таблицы~\ref{second-enc-table}.

К сожалению, на практике эта модификация не принесла ожидаемого ускорения, поэтому результаты её тестирования не приведены в следующей главе.
Возможно, подбор подходящего солвера принесет какие-то результаты.
Кроме того, возможен вариант сведения, не использующий утверждения из параграфа~\ref{sec:structure}.
Этот вариант сведения будет исследован в дальнейшей работе.
